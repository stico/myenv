#!/bin/bash

#function func_tag_text_value {
#	usage="Usage: func_tag_text_value [tag]"
#	[[ -z $1 ]] && echo $usage && return 1
#
#	tags=$MY_ENV_LIST/tags
#	sed -n -e "s/${1}=//p" $tags
#}

function func_tag_value {
	# DESC: translate a tag value, or return itself if not a tag

	# empty parameter, empty output
	[ -z "$*" ] && return 1

	# NO translation, probably path, translate will also cause problem
	[ "$*" = "." -o "$*" = ".." ] && echo $* && return 0

	# NO translation, contain no-tag char
	[ $(echo "$*" | grep -c "/\| ") -ge 1 ] && echo $* && return 0

	# check tag
	tags=$MY_ENV_LIST/tags
	tag_value=`sed -n -e "s/${1}=//p" $tags`

	# not a tag, return itself
	[[ -z $tag_value ]] && echo $1 && return 0

	# eval value if contains var or cmd substitution, otherwise return itself
	[ $(echo $tag_value | grep -c '`\|$') -ge 1 ] && eval "echo $tag_value" || echo $tag_value
}

function func_select_line {
	usage="Usage: func_select_line [result_var_name] [lines]"
	[ $# -lt 2 ] && echo $usage && return 1

	# need use variable to "return" result
	result_var_name=$1
	eval $result_var_name=""
	shift

	# empty parameter, empty output
	[ -z "$*" ] && return 1
	
	targets_lines=$(echo "$*" | wc -l)
	[ $targets_lines -eq 1 ] && eval $result_var_name="$*" && return 0

	func_head 20 "$*" | cat -n | sed -e "s/\s\+\([0-9]\+\).*/& \1/"
	echo "NOT SINGLE CANDIDATES, PLS SELECT ONE:"
	read -e selection
	user_selection=`echo "$*" | sed -n -e "${selection}p"`
	eval $result_var_name=$user_selection
}

function func_find_cache {
	# NOTE: must keep interface consistency with func_find
	usage="Usage: func_find [result_var_name] [find_type] [base] [pattern]"
	[ $# -lt 4 ] && echo $usage && return 1

	# need use variable to "return" result
	result_var_name=$1
	find_type=$2
	shift;shift
	eval $result_var_name=""

	#targets=`func_find_type $find_type $*`			# (2013-05-23) works, non cache version	
	targets=`func_find_type_cache $find_type $*`
	func_select_line $result_var_name "$targets"
}

function func_find {
	# NOTE: must keep interface consistency with func_find_cache
	usage="Usage: func_find [result_var_name] [find_type] [base] [pattern]"
	[ $# -lt 4 ] && echo $usage && return 1

	# need use variable to "return" result
	result_var_name=$1
	find_type=$2
	shift;shift
	eval $result_var_name=""

	targets=`func_find_type $find_type $*`
	func_select_line $result_var_name "$targets"
}

function func_find_type_cache {
	# NOTE: must keep interface consistency with func_find_type
	usage="Usage: func_find_type_cache [find_type] [base] [pattern]"
	[ $# -lt 3 ] && echo $usage && return 1

	find_type=$1
	base=$2
	shift;shift

	if [ "$find_type" = "d" ] ; then
		list_file=".dl_me.txt" 
		func_gen_dirlist $base $list_file
	else
		list_file=".fl_me.txt"
		func_gen_filelist $base $list_file
	fi

	search=`echo "$*" | sed -e '/^$/q;s/ \|^/.*\/.*/g;s/\$/[^\/]*/'`
	targets=`cat $base/$list_file | sed -e "/^$/d" | grep "$search"`

	echo "$targets"
}

function func_find_type {
	# NOTE: must keep interface consistency with func_find_type_cache
	usage="Usage: func_find_type [find_type] [base] [pattern]"
	[ $# -lt 3 ] && echo $usage && return 1

	find_type=$1
	base=$2
	shift;shift

	search=`echo "$*" | sed -e '/^$/q;s/ \|^/.*\/.*/g;s/\$/[^\/]*/'`
	targets=`find -P "$base" -iregex "$search" -xtype $find_type | sed -e "/^$/d"`				# 1st try, not follow links
	[ -z "$targets" ] && targets=`find -L "$base" -iregex "$search" -type $find_type | sed -e "/^$/d"`	# not found, follow links maybe works
	[ -z "$targets" ] && return 1										# not found, return

	echo "$targets"
}

#function func_cd {
#	[ -z "$*" ] && \cd && return 0
#
#	base="$1"
#	base_eval="`func_tag_value $1`"
#	[ -n "${base_eval}" ] && base=${base_eval}
#	shift
#	[ -z "$*" ] && func_cd_conditional $base && return 0
#
#	#func_find result_target d $base $*			# (2013-05-23) works, non cache version	
#	func_find_cache result_target d $base $*
#	[ -d $result_target ] && func_cd_conditional $result_target || func_cd_conditional `dirname $result_target`
#}

function func_vi_path_conv {
	# DESC: the win version vim need win style path

	# non-cygwin env, use original style
	[ $(func_sys_info | grep -c "^cygwin") = 0 ] && echo "$*" && return 0

	# cygwin use win style path
	cygpath -w "$*"
}

function func_vi {
	# TODO: when the vi quit, will show a job exit report line, how to suppress it?

	# choose cmd for term and gui
	[ -n "$DISPLAY" ] && vi_cmd=vim || vi_cmd=gvim

	# shortcut - open a new one
	[ -z "$*" ] && (\\$vi_cmd &>/dev/null &) && return 0

	# shortcut - only one parameter, and exist
	tag_eval="`func_tag_value $1`"
	[ $# -eq 1 ] && (\\$vi_cmd `func_vi_path_conv "$tag_eval"` &>/dev/null &) && return 0

	# otherwise need search
	[ "$tag_eval" != "$1" ] && base="$tag_eval" && shift || base="./"

	#func_find result_target f $base $*			# (2013-05-23) works, non cache version	
	func_find_cache result_target f $base $*
	\\$vi_cmd `func_vi_path_conv "$base/$result_target"` &>/dev/null &
}

function func_cd {
	# shortcut - home
	[ -z "$*" ] && \cd && return 0

	# shortcut - only one parameter, and exist
	tag_eval="`func_tag_value $1`"
	[ $# -eq 1 ] && [ -d $tag_eval ] && func_cd_conditional $tag_eval && return 0

	# otherwise need search
	[ "$tag_eval" != "$1" ] && base="$tag_eval" && shift || base="./"

	#func_find result_target d $base $*			# (2013-05-23) works, non cache version	
	func_find_cache result_target d $base $*
	[ ! -e $base/$result_target ] && echo "ERROR: $base/$result_target not exist! pls check"
	[ -d $base/$result_target ] && func_cd_conditional $base/$result_target || func_cd_conditional `dirname $base/$result_target`
}

function func_cd_tmp_today { 
	# so could evaluate the date every time
	func_mkdir_cd $MY_TMP/`date "+%Y-%m-%d"`	
}

function func_cd_conditional {
	usage="Usage: func_cd_conditional [target]"
	[ $# -lt 1 ] && echo $usage && return 1
	
	# use rvm's cd function if needed (note, the func_rvm_cd is hacked in .bashrc
	[ "$(type -t func_rvm_cd)" = "function" -a -e "$*/.rvmrc" ] && func_rvm_cd "$*" && return 0

	# otherwise just cd, use "\cd" to avoid infinite loop, since cd is hacked
	\cd "$*"
	func_head_cmd 10 ll
}

function func_head_cmd {
	usage="Usage: func_head_cmd [show_lines] [cmd]"
	[ $# -lt 2 ] && echo $usage && return 1

	show_lines=$1
	shift

	cmd_result=`eval "$*"`
	func_head $show_lines "$cmd_result"
}

function func_gen_filelist {
	# TODO: if possible to identify the dir (suffix /)
	# TODO: check if has write permintion before gen?
	# TODO: if path is home or above, should not gen filelist?
	#[ "`realpath $base`" = "`realpath $HOME`" ] && echo yes || echo no

	# NOTE: must keep interface consistency with func_gen_dirlist
	# DESC: only gen file list
	usage="Usage: func_gen_filelist [base] [fl_name]"
	[ $# -lt 2 ] && echo $usage && return 1

	base=$1
	filelist=$2
	[ -e $base/$filelist ] && return 0

	# make the path relative to the base, for better compitability
	echo "$base/$filelist not exist, create it..." 1>&2
	\cd $base
	find ./ -type f > $filelist
	\cd -
}

function func_gen_dirlist {
	# NOTE: must keep interface consistency with func_gen_filelist
	# DESC: only gen dir list
	usage="Usage: func_gen_dirlist [base] [dl_name]"
	[ $# -lt 2 ] && echo $usage && return 1

	base=$1
	dirlist=$2
	[ -e $base/$dirlist ] && return 0

	# make the path relative to the base, for better compitability
	echo "$base/$dirlist not exist, create it..." 1>&2
	\cd $base
	find -L ./ -type d > $base/$dirlist
	\cd -
}

function func_gen_filelist_myenv {

	filelist=$MY_ENV/.fl_me.txt

	[ -e $filelist ] && return 0

	cat $MY_ENV_ZGEN/myenv.lst > $filelist				# override
	for add_path in $HOME/.ssh $MY_ENV/SECU $MY_ENV/SECURE ; do
		[ -e $add_path ] && find $add_path -type f >> $filelist	# append
	done
}

function func_gen_grep_result {

	# TODO
	# - seems can not support grepfile "aaa\|bbb"
	# - seems can not add more options

	usage="Usage: func_gen_grep_result [base] [suffix] [search]*"
	[ $# -lt 3 ] && echo $usage && return 1

	base=$1
	file_suffix=`[ "$2" = "ALL" ] && echo "" || echo ".$2"`
	shift;shift

	filelist=.fl_me.txt
	grep_result=.grep_me.txt

	func_gen_filelist $base $filelist

	# we treat path in search text as .
	search_string="$*"
	search=${search_string//\\/.}

	# Jump to base, since the filelist is using relative path
	\cd $base
	grep $suffix'$' $filelist	| \
	# Step: remove files not need to grep (for "grepfile")
	sed -e "/\/.svn\//d" 		| \
	sed -e "/\/.hg\//d" 		| \
	sed -e "/\/.git\//d"		| \
	sed -e "/\/.lnk\//d"		| \
	sed -e "/\/.metadata\//d"	| \
	sed -e "/\/.class$\//d"		| \
	sed -e "/.grep_result.txt/d"	| \
	sed -e "/.grep_me.txt/d"	| \
	sed -e "/\/.jar$\//d"		| \
	# Step: special removal, the target is mvn, but might cause miss-hit!
	sed -e "/\/target\//d"		| \
	# Step: remove the fileist itself
	sed -e "/$filelist$/d"		| \
	# Step: grep result, -I is not match binary files
	xargs --delimiter="\n" grep -I -i "$search" | tee $grep_result | grep --color -i "$search"

	# Jump back
	\cd -
}

function func_gen_grep_result_myenv { 
	usage="Usage: func_gen_grep_result_myenv [search]*"
	[ $# -lt 1 ] && echo $usage && return 1

	func_gen_filelist_myenv 
	func_gen_grep_result $MY_ENV ALL "$*"
}

function func_head {
	usage="Usage: func_head_cmd [show_lines] [text]"
	[ $# -lt 2 ] && echo $usage && return 1

	show_lines=$1
	shift

	total_lines=$(echo "$*" | wc -l)
	echo "$*" | sed -n -e "1,${show_lines}p;21s/.*/( ...... WARN: more lines suppressed, $total_lines total ...... )/p"
}

function func_ls { 
	# FOR_DEV: w | !source /home/ouyangzhu/.myenv/env_func_bash; func_ls dev

	usage="Usage: func_ls [tag] [path]*"
	[[ -z $1 ]] && echo $usage && return 1

	# TODO: how to distiguish ll/ls/lla etc

	# TODO: Avoid Filename_Expansion

	# TODO: For Cmd History: ls the cmd output dir?

	# Translate tag
	base="./"
	if [[ -n "`func_tag_text_value $1`" ]] ;then 
		base="`func_tag_eval_value $1`/"
		shift
	fi
	pathPattern=`echo "$*" | sed -e '/^$/q;s/ /*\//g;s/$/*/'`

	echo ------------------------------------"$base/$pathPattern"
	ls -lhtrF --color=auto $base/$pathPattern

	# Tmp Cmd
	#search=`echo "$*" | sed -e '/^$/q;s/ \|^\|$/.*/g'`
	#[[ -n $search ]] && search="-iregex $search"
	#find $base $search 
}

function func_ip {
	/sbin/ifconfig 									\
	| grep -B1 "inet addr" 								\
	| awk '{ if($1=="inet"){print $2}else if($2=="Link"){ printf "%s:", $1}}'	\
	| awk -F: '{ print $1 ": " $3 }'; 
}

function func_mkdir_cd { 
	usage="Usage: func_mkdir_cd [path]"
	[[ -z $1 ]] && echo $usage && return 1

	mkdir -p "$@" 				&&
	# why need such complex eval?
	eval \cd "\"\$$#\""
}

function func_show_resp { 
	usage="Usage: func_show_resp [url]"
	[[ -z $1 ]] && echo $usage && return 1

	echo "sending request to: $1"
	wget --timeout=2 --tries=1 -O - 2>&1 "$1"	\
	| sed -e '/'${1//\//.}'/d'			\
	| sed -e '/^Resolving/d'			\
	| sed -e '/^Length/d'				\
	| sed -e '/^Saving/d;/100%.*=.*s/d'		\
	| sed -e '/0K.*0.00.=0s/d'			\
	| sed -e '/^$/d'
}

function func_git_pull { 
	usage="Usage: func_git_pull [code_base]"
	[[ -z $1 ]] && echo $usage && return 1

	\cd $1		 			&&
	git pull github master 			&&
	git status	 			&&
	\cd -
}

function func_git_status { 
	usage="Usage: func_git_status [code_base]"
	[[ -z $1 ]] && echo $usage && return 1

	\cd $1					&&	
	git status 	
	\cd -
}

function func_git_commit_push { 
	usage="Usage: func_git_commit_push [code_base] [comment]"
	[[ -z $1 || -z $2 ]] && echo $usage && return 1

	\cd $1					&& 
	git pull github master			&&
	git add .				&&
	shift					&&
	git commit -a -m "$*" 			&&
	git push github				&&
	git status 				&&
	bash $MY_ENV_LIST/myenv_gen.sh		&&
	\cd - 
}

function func_ssh_with_jump {
	usage="Usage: func_ssh_with_jump [target]"
	[[ -z $1 ]] && echo $usage && return 1

	ip_addr=`getent hosts $1 | sed "s/\s\+.*$//"`
	[[ -z $ip_addr ]] && ip_addr=$1

	PORT=32200
	JUMP_MACHINE=dw
	
	shift
	ssh -t $JUMP_MACHINE "ssh -p $PORT $ip_addr $@"

	# TODO: check the $1, if it is a ip, should not parse as hostname
	# TODO: add function for run cmd on multiple host
	# Demo: func_ssh_with_jump 222.88.95.197 
}

function func_scp_with_jump {
	usage="Usage: func_scp_with_jump [source] [target]"
	[[ -z $1 || -z $2 ]] && echo $usage && return 1

	PORT=32200
	JUMP_MACHINE=dw

	source=$1
	sourceName=$(basename $source)
	tmpTransferName=tmp_transfer_`date "+%Y-%m-%d_%H-%M-%S"`_${sourceName}
	target=$2
	targetDir=$(dirname ${target##*:})
	targetCmd="mkdir -p $targetDir"
	targetAddr=${target%%:*}

	if [[ $(echo $1 | grep -c ":") == 1 ]] 
	then
		echo "Downloading ..."

		# download content to jump machine
		ssh $JUMP_MACHINE "scp -r -P $PORT $source ~/$tmpTransferName"

		# create dir and download content to local machine 
		$targetCmd
		[[ -d $target ]] && targetFullName=$target/$sourceName
		scp -r -P $PORT ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName $targetFullName
	else
		echo "Uploading ..."

		# upload content to jump machine
		scp -r -P $PORT $source ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName

		# create dir and upload content to target machine in jump machine
		ssh $JUMP_MACHINE "ssh -p $PORT $targetAddr $targetCmd"
		# TODO: support rename in target (see above)
		ssh $JUMP_MACHINE "scp -r -P $PORT ~/$tmpTransferName $target"
	fi

	# delete tmp file in jump machine
	ssh $JUMP_MACHINE "rm -rf ~/$tmpTransferName"

	# Note: seems using ProxyCommand is a better way (not totally work yet), see ~/.ssh/config for more detail

	# Improve: the file name was changed to tmp_xxx
	# Improve: support hostname (need translate, since the jump machine didn't set the hosts)
	# Improve: support file name with wildcard
	# Improve: cache the file based on MD5?
	# Improve: support all senario 
	#	L > R	I	cmd on L(src=L-Path		target=J-Host-Tmp)		II: cmd on J(src=J-Tmp	target=R-Host-Path)
	#	R > L	II	cmd on J(src=R-Host-Path	target=J-Tmp)			II: cmd on L(src=L-Path	target=J-Host-Tmp)
	#	R1 > R2	III	cmd on J(src=R1-Host-Path	target=J-Tmp)			II: cmd on J(src=J-Tmp	target=R2-Host-Tmp)
	#
	#	rule for scp exe location		J if $1 contains :, otherwise L
	#	rule for scp exe stage 1 src		directly use
	#	rule for scp exe stage 1 target		J-Tmp if $1 contains :, otherwise J-Host-Tmp
	#	rule for scp exe stage 2 src		J-Tmp if $2 contains :, otherwise directly use
	#	rule for scp exe stage 2 target		directly use if $2 contains :, otherwuse J-Host-Tmp
	#
	#	and mkdir?

	# Demo: 
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test
		#func_scp_with_jump ~/amp/test/t1 ouyangzhu@222.134.66.106:~/test1
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test2/test
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test/t1 ~/amp/2012-11-01/test1
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test ~/amp/2012-11-01/test
}

function func_sys_info { 
	# format: <os_name>          		_<os_ver>  _<os_len>     _<os_type>               _<hostname>	_<addInfo>
	# exampe: ubuntu/linuxmint/cygwin/win	_12.04     _64bit/32bit  _desktop/server/win7/xp  _workvm	_precise

	(command -v uname &> /dev/null) && uname_info=`uname -a` || uname_info="cmd_uname_not_exist"

	# os_name
	if [ -e /etc/lsb-release ] ; then					os_name=`sed -n -e "s/DISTRIB_ID=\(\S*\)/\L\1/p" /etc/lsb-release`
	elif [ $(echo $uname_info | grep -ic "cygwin") -eq 1 ] ; then		os_name="cygwin"
	elif [ $(echo $uname_info | grep -ic "mingw") -eq 1 ] ; then		os_name="mingw"
	else									os_name="unknown"
	fi

	# use cache if cached, need os_name to distiguish cygwin/mingw
	if [ -n $MY_ENV_ZGEN ] ; then						cache_file=$MY_ENV_ZGEN/sys_info_${os_name}
	else									cache_file=/tmp/sys_info_${os_name}
	fi
	[ -e $cache_file ] && cat $cache_file && return

	# os_ver
	if [ -e /etc/lsb-release ] ; then					os_ver=`sed -n -e "s/DISTRIB_RELEASE=\(\S*\)/\1/p" /etc/lsb-release`
	elif [ "$os_name" = "cygwin" ] ; then					os_ver=`uname -r | sed -e "s/(.*//"`
	else									os_ver="unknown"
	fi
	
	# os_len, note, cygwin is usually 32bit
	if [ $(echo $uname_info | grep -ic "x86_64") -eq 1 ] ; then		os_len="64bit"
	elif [ $(echo $uname_info | grep -ic "i[3-6]86") -eq 1 ] ; then		os_len="32bit"
	else									os_len="unknown"
	fi

	# os_type
	if [ "$os_name" = "ubuntu" ] && (command -v dpkg &> /dev/null) ; then 
		if (dpkg -l ubuntu-desktop &> /dev/null) ; then			os_type="desktop"
		else								os_type="server"
		fi
	elif [ "$os_name" = "cygwin" -o "$os_name" = "mingw" ] ; then		os_type="desktop"
	elif [ "$os_name" = "linuxmint" ] ; then				os_type="desktop"
	else									os_type="unknown"
	fi

	# hostname
	hostname=`hostname`

	# addInfo
	if [ "$os_name" = "ubuntu" ] ; then					addInfo=`sed -n -e "s/DISTRIB_CODENAME=\(\S*\)/\L\1/p" /etc/lsb-release`
	fi
	############################################################## (not include in output yet)
	# cpu_type 
	cpu_type="unknown"

	# cpu_len 
	# if [ $(grep -c "flags.* lm " /proc/cpuinfo) -ge 1 ] ; then # lm (long bit), deprecated
	if [ $(getconf -a | grep -c "LONG_BIT\s*64") -eq 1 ] ; then		cpu_len=64bit
	elif [ $(getconf -a | grep -c "LONG_BIT\s*32") -eq 1 ] ; then		cpu_len=32bit
	else									cpu_len="unknown"
	fi
	############################################################## (not include in output yet)

	echo -e "${os_name}_${os_ver}_${os_len}_${os_type}_${hostname}_${addInfo}" > $cache_file
	cat $cache_file

	# TODO: put this func to another file, pre load as basic functions
}

function func_translate { 
	# usage: func_translate lovely world

	# TODO: parse all contents, e.g. when translate "break"
	# TODO: record history

	# might useful fields: ie=UTF-8&oe=UTF-8
	if [ $( echo $* | grep -c "[a-z]") -ge 1 ] ; 
	then	data="hl=en&tsel=0&ssel=0&client=t&sc=1&multires=1&otf=2&text=$*&tl=zh-CN&sl=en"	# en > cn
	else	data="hl=en&tsel=0&ssel=0&client=t&sc=1&multires=1&otf=2&text=$*&tl=en&sl=zh-CN"	# cn > en	# why become cn > cn !!??
	fi

	res_raw=`curl -e "http://translate.google.cn/?"							\
		-H 'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:11.0) Gecko/20100101 Firefox/11.0'	\
		-H 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'			\
		-s "http://translate.google.cn/translate_a/t"							\
		-d "$data"`

	res_simple=`echo $res_raw | awk -F"," '{printf "%s\n", $1}' | awk -F"\"" '{print $2}'`
	#| awk -F"," '{printf "%s\n%s\n%s\n", $2,$3,$1}' 	

	echo $res_raw
	echo $res_simple

}
