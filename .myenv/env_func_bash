#!/bin/bash

function func_cd { 
	cd $1
	shift
	for path in $@ ; do
		cd *${path}*
		shift
	done

	eval ll
	# might have more hack in future
}

function func_ip {
	/sbin/ifconfig 									\
	| grep -B1 "inet addr" 								\
	| awk '{ if($1=="inet"){print $2}else if($2=="Link"){ printf "%s:", $1}}'	\
	| awk -F: '{ print $1 ": " $3 }'; 
}

function func_mkdir_cd { 
	usage="Usage: func_mkdir_cd [path]"
	[[ -z $1 ]] && echo $usage && return 1

	mkdir -p "$@" 				&&
	# why need such complex eval?
	eval cd "\"\$$#\""
}

function func_cd_tmp_today { 
	# so could evaluate the date every time
	func_mkdir_cd $MY_TMP/`date "+%Y-%m-%d"`	
}

function func_show_resp { 
	usage="Usage: func_show_resp [url]"
	[[ -z $1 ]] && echo $usage && return 1

	echo "sending request to: $1"
	wget --timeout=2 --tries=1 -O - 2>&1 "$1"	\
	| sed -e '/'${1//\//.}'/d'			\
	| sed -e '/^Resolving/d'			\
	| sed -e '/^Length/d'				\
	| sed -e '/^Saving/d;/100%.*=.*s/d'		\
	| sed -e '/0K.*0.00.=0s/d'			\
	| sed -e '/^$/d'
}

function func_git_pull { 
	usage="Usage: func_git_pull [code_base]"
	[[ -z $1 ]] && echo $usage && return 1

	cd $1		 			&&
	git pull github master 			&&
	git status	 			&&
	cd -
}

function func_git_status { 
	usage="Usage: func_git_status [code_base]"
	[[ -z $1 ]] && echo $usage && return 1

	cd $1					&&	
	git status 	
	cd -
}

function func_git_commit_push { 
	usage="Usage: func_git_commit_push [code_base] [comment]"
	[[ -z $1 || -z $2 ]] && echo $usage && return 1

	cd $1					&& 
	git pull github master			&&
	git add .				&&
	shift					&&
	git commit -a -m "$*" 			&&
	git push github				&&
	git status 				&&
	bash $MY_ENV_LIST/myenv_gen.sh		&&
	cd - 
}

function func_e_grep { 
	usage="Usage: func_e_grep [pattern]"
	[[ -z $1 ]] && echo $usage && return 1

	cd $HOME
	cat $MY_ENV_ZGEN/myenv.lst | xargs grep -i "$1" > .grep_result.txt
	grep -i --color "$1" .grep_result.txt
	# this not work when $1 has grouping "\(\)": eval grepi "$1" .grep_result.txt
	cd -
}

function func_ssh_with_jump {
	usage="Usage: func_ssh_with_jump [target]"
	[[ -z $1 ]] && echo $usage && return 1

	ip_addr=`getent hosts $1 | sed "s/\s\+.*$//"`
	[[ -z $ip_addr ]] && ip_addr=$1

	PORT=32200
	JUMP_MACHINE=dw
	
	shift
	ssh -t $JUMP_MACHINE "ssh -p $PORT $ip_addr $@"

	# TODO: check the $1, if it is a ip, should not parse as hostname
	# TODO: add function for run cmd on multiple host
	# Demo: func_ssh_with_jump 222.88.95.197 
}

function func_scp_with_jump {
	usage="Usage: func_scp_with_jump [source] [target]"
	[[ -z $1 || -z $2 ]] && echo $usage && return 1

	PORT=32200
	JUMP_MACHINE=dw

	source=$1
	sourceName=$(basename $source)
	tmpTransferName=tmp_transfer_`date "+%Y-%m-%d_%H-%M-%S"`_${sourceName}
	target=$2
	targetDir=$(dirname ${target##*:})
	targetCmd="mkdir -p $targetDir"
	targetAddr=${target%%:*}

	if [[ $(echo $1 | grep -c ":") == 1 ]] 
	then
		echo "Downloading ..."

		# download content to jump machine
		ssh $JUMP_MACHINE "scp -r -P $PORT $source ~/$tmpTransferName"

		# create dir and download content to local machine 
		$targetCmd
		[[ -d $target ]] && targetFullName=$target/$sourceName
		scp -r -P $PORT ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName $targetFullName
	else
		echo "Uploading ..."

		# upload content to jump machine
		scp -r -P $PORT $source ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName

		# create dir and upload content to target machine in jump machine
		ssh $JUMP_MACHINE "ssh -p $PORT $targetAddr $targetCmd"
		# TODO: support rename in target (see above)
		ssh $JUMP_MACHINE "scp -r -P $PORT ~/$tmpTransferName $target"
	fi

	# delete tmp file in jump machine
	ssh $JUMP_MACHINE "rm -rf ~/$tmpTransferName"

	# Note: seems using ProxyCommand is a better way (not totally work yet), see ~/.ssh/config for more detail

	# Improve: the file name was changed to tmp_xxx
	# Improve: support hostname (need translate, since the jump machine didn't set the hosts)
	# Improve: support file name with wildcard
	# Improve: cache the file based on MD5?
	# Improve: support all senario 
	#	L > R	I	cmd on L(src=L-Path		target=J-Host-Tmp)		II: cmd on J(src=J-Tmp	target=R-Host-Path)
	#	R > L	II	cmd on J(src=R-Host-Path	target=J-Tmp)			II: cmd on L(src=L-Path	target=J-Host-Tmp)
	#	R1 > R2	III	cmd on J(src=R1-Host-Path	target=J-Tmp)			II: cmd on J(src=J-Tmp	target=R2-Host-Tmp)
	#
	#	rule for scp exe location		J if $1 contains :, otherwise L
	#	rule for scp exe stage 1 src		directly use
	#	rule for scp exe stage 1 target		J-Tmp if $1 contains :, otherwise J-Host-Tmp
	#	rule for scp exe stage 2 src		J-Tmp if $2 contains :, otherwise directly use
	#	rule for scp exe stage 2 target		directly use if $2 contains :, otherwuse J-Host-Tmp
	#
	#	and mkdir?

	# Demo: 
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test
		#func_scp_with_jump ~/amp/test/t1 ouyangzhu@222.134.66.106:~/test1
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test2/test
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test/t1 ~/amp/2012-11-01/test1
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test ~/amp/2012-11-01/test
}

function func_sys_info { 
	# format: <os_name>          _<os_ver>  _<os_len>     _<os_type>               _<hostname>
	# exampe: ubuntu/cygwin/win  _12.04     _64bit/32bit  _desktop/server/win7/xp  _workvm    

	(command -v uname &> /dev/null) && uname_info=`uname -a` || uname_info="cmd_uname_not_exist"

	# os_name
	if [ -e /etc/lsb-release ] ; then				os_name=`sed -n -e "s/DISTRIB_ID=\(\S*\)/\L\1/p" /etc/lsb-release`
	elif [ $(echo $uname_info | grep -ic "cygwin") -eq 1 ] ; then	os_name="cygwin"
	elif [ $(echo $uname_info | grep -ic "mingw") -eq 1 ] ; then	os_name="mingw"
	else								os_name="unknown"
	fi

	# use cache if cached, need os_name to distiguish cygwin/mingw
	[ -n $MY_ENV_ZGEN ] && cache_file=$MY_ENV_ZGEN/sys_info_${os_name} || cache_file=/tmp/sys_info_${os_name}
	[ -e $cache_file ] && cat $cache_file && return

	# os_ver
	if [ -e /etc/lsb-release ] ; then	os_ver=`sed -n -e "s/DISTRIB_RELEASE=\(\S*\)/\1/p" /etc/lsb-release`
	elif [ "$os_name" = "cygwin" ] ; then	os_ver=`uname -r | sed -e "s/(.*//"`
	else					os_ver="unknown"
	fi
	
	# os_len, note, cygwin is usually 32bit
	if [ $(echo $uname_info | grep -ic "x86_64") -eq 1 ] ; then			os_len="64bit"
	elif [ $(echo $uname_info | grep -ic "i386\|i486\|i586\|i686") -eq 1 ] ; then	os_len="32bit"
	else										os_len="unknown"
	fi

	# os_type
	if [ "$os_name" = "ubuntu" ] && (command -v dpkg &> /dev/null) ; then 
		if (dpkg -l ubuntu-desktop &> /dev/null) ; then			os_type="desktop"
		else								os_type="server"
		fi
	elif [ "$os_name" = "cygwin" -o "$os_name" = "mingw" ] ; then		os_type="desktop"
	else									os_type="unknown"
	fi

	# hostname
	hostname=`hostname`

	############################################################## (not include in output yet)
	# cpu_type 
	cpu_type="unknown"

	# cpu_len 
	# if [ $(grep -c "flags.* lm " /proc/cpuinfo) -ge 1 ] ; then # lm (long bit), deprecated
	if [ $(getconf -a | grep -c "LONG_BIT\s*64") -eq 1 ] ; then	cpu_len=64bit
	elif [ $(getconf -a | grep -c "LONG_BIT\s*32") -eq 1 ] ; then	cpu_len=32bit
	else								cpu_len="unknown"
	fi
	############################################################## (not include in output yet)

	echo -e "${os_name}_${os_ver}_${os_len}_${os_type}_${hostname}" > $cache_file
	cat $cache_file

	# TODO: put this func to another file, pre load as basic functions
}

