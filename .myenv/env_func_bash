#!/bin/bash

function func_date {
	date "+%Y-%m-%d"
}

function func_time {
	date "+%H-%M-%S"
}

function func_dati {
	date "+%Y-%m-%d_%H-%M-%S"
}

function func_die {
	usage="Usage: $FUNCNAME [error_info]"
	[ $# -lt 1 ] && echo -e "${usage}\n$@" && exit 1
	
	echo "$@" 1>&2

	# return if invoked from command line, exit if from script. 
	# BUT messy up invoke chain 
	#[ "$0" = "/bin/bash" ] && return 1 || exit 1

	# easy solution
	exit 1
}

function func_param_check {
	usage="Usage: $FUNCNAME [param_count] [error_info]"

	# usge -ge, so the exit status will not changed in legal condition
	[ $# -ge 2 ] || func_die $usage
	
	param_count=$1
	error_info=$2
	shift;shift;

	[ $# -lt $param_count ] && func_die $error_info
}

function func_validate_exist() {
	func_param_check 1 "USAGE: $FUNCNAME <path> <path> ..." "$@" 
	
	for path in $@ ; do
		[ ! -e "$path" ] && echo "ERROR: $path NOT exist!" && exit 1
	done
}

function func_validate_inexist() {
	func_param_check 1 "USAGE: $FUNCNAME <path> <path> ..." "$@" 
	
	for path in $@ ; do
		[ -e "$path" ] && echo "ERROR: $path already exist!" && exit 1
	done
}

function func_validate_user_name() {
	func_param_check 1 "USAGE: $FUNCNAME <username>" "$@"
	
	[ "`whoami`" != "$*" ] && echo "ERROR: username is not $* !" && exit 1
}

function func_validate_user_exist() {
	func_param_check 1 "USAGE: $FUNCNAME <username>" "$@"
	
	( ! grep -q "^$*:" /etc/passwd ) && echo "ERROR: user '$*' not exist!" && exit 1
}

function func_validate_cmd_exist() {
	func_param_check 1 "USAGE: $FUNCNAME <command>" "$@"

	( ! command -v "$1" &> /dev/null) && echo "ERROR: $1 not found (in PATH)" && exit 1
}

function func_bak_file {
	func_param_check 1 "USAGE: $FUNCNAME <filename>" "$@"

	[ -d "${1}" ] && echo "ERROR: $1 is a directory" && exit 1
	
	target=${1}.bak_$(func_dati)
	[ -w "$(dirname ${1})" ] && cp "$1" $target || sudo cp "$1" $target 
}

function func_tag_value {
	#desc="Desc: translate a tag value, or return itself if not a tag"
	#usage="Usage: $FUNCNAME [filename]"
	#[ $# -lt 1 ] && echo -e "${desc}\n${usage}" && exit 1

	# NO translation, empty parameter, empty output
	[ -z "$*" ] && return 1

	# NO translation, probably path, translate will also cause problem
	[ "$*" = "." -o "$*" = ".." ] && echo $* && return 0

	# NO translation, contain no-tag char
	[ $(echo "$*" | grep -c "/\| ") -ge 1 ] && echo $* && return 0

	# check tag
	tags=$MY_ENV_LIST/tags
	tag_value=`sed -n -e "s/^${1}=//p" $tags`

	# not a tag, return itself
	[ -z "$tag_value" ] && echo $1 && return 0

	# eval
	func_tag_eval $tag_value
}

function func_tag_eval {
	func_param_check 1 "USAGE: $FUNCNAME <tag>" "$@"

	tag=$*

	# eval value if contains var or cmd substitution, otherwise return itself
	if [ $(echo $tag | grep -c '`\|$') -ge 1 ] ; then
		# remove starting and trailing quotes, otherwise eval will fail
		#tag=`echo $tag | sed -e "s/^['\"]//;s/['\"]$//"`		

		eval echo $tag
	else
		echo $tag
	fi
}

function func_path_eval {
	func_param_check 2 "Usage: $FUNCNAME <result_var_name> <pathstr>" "$@"

	# need use variable to "return" result
	result_var_name=$1
	eval $result_var_name=""
	shift
	pathstr="$*"

	# eval path, check empty value
	[ -n "$pathstr" ] && candidate=`func_tag_value $pathstr`
	[ -z "$candidate" ] && echo -e "WARN: candiate is empty: $pathstr !" && return 1

	# Try $HOME as base (myenv backup need this for git listed files)
	[ -e "$HOME/$candidate" ] && eval $result_var_name="$HOME/$candidate" && return 0
	[ -e "$candidate" ] && eval $result_var_name="$candidate" && return 0
}

function func_select_line {
	func_param_check 3 "Usage: $FUNCNAME <result_var_name> <shortest|userselect> <lines>" "$@"

	# need use variable to "return" result
	result_var_name=$1
	eval $result_var_name=""
	shift

	# empty parameter, empty output
	[ -z "$*" ] && return 1
	
	# direct return for shortest
	select_type=$1
	shift
	[ "shortest" = "$select_type" ] && eval $result_var_name=`echo "$*" | awk '{ print length, $0 }' | sort -n | cut -d" " -f2- | head -1` && return 0

	targets_lines=$(echo "$*" | wc -l)
	[ $targets_lines -eq 1 ] && eval $result_var_name="$*" && return 0

	func_head 20 "$*" | cat -n | sed -e "s/\s\+\([0-9]\+\).*/& \1/"
	echo "NOT SINGLE CANDIDATES, PLS SELECT ONE:"
	read -e selection
	user_selection=`echo "$*" | sed -n -e "${selection}p"`
	eval $result_var_name=$user_selection
}

function func_find_type_cache {
	# NOTE: must keep interface consistency with func_find_type
	func_param_check 3 "Usage: $FUNCNAME [find_type (f,file;d,dir)] [base] [pattern]" "$@"

	find_type=$1
	base=$2
	shift;shift

	if [ "$find_type" = "d" ] ; then
		list_file=".dl_me.txt" 
		func_gen_list d $base $list_file || return 1
	else
		list_file=".fl_me.txt"
		func_gen_list f $base $list_file || return 1
	fi

	search=`echo "$*" | sed -e '/^$/q;s/ \|^/.*\/.*/g;s/\$/[^\/]*/'`
	targets=`cat $base/$list_file | sed -e "/^$/d" | grep -i "$search"`

	echo "$targets"
}

function func_find_type {
	# NOTE: must keep interface consistency with func_find_type_cache
	func_param_check 3 "Usage: $FUNCNAME [find_type (f,file;d,dir)] [base] [pattern]" "$@"

	find_type=$1
	base=$2
	shift;shift

	search=`echo "$*" | sed -e '/^$/q;s/ \|^/.*\/.*/g;s/\$/[^\/]*/'`
	targets=`find -P "$base" -iregex "$search" -xtype $find_type | sed -e "/^$/d"`				# 1st try, not follow links
	[ -z "$targets" ] && targets=`find -L "$base" -iregex "$search" -type $find_type | sed -e "/^$/d"`	# not found, follow links maybe works
	[ -z "$targets" ] && return 1										# not found, return

	echo "$targets"
}

function func_find_cache {
	# NOTE: must keep interface consistency with func_find
	func_param_check 4 "Usage: $FUNCNAME [result_var_name] [find_type (f,file;d,dir)] [base] [pattern]" "$@"

	# need use variable to "return" result
	result_var_name=$1
	find_type=$2
	shift;shift
	eval $result_var_name=""

	#targets=`func_find_type $find_type $*`			# (2013-05-23) works, non cache version	
	targets=$(func_find_type_cache $find_type $*)
	[ $? -ne 0 ] && return 1

	func_select_line $result_var_name shortest "$targets"
}

function func_find {
	# NOTE: must keep interface consistency with func_find_cache
	func_param_check 4 "Usage: $FUNCNAME [result_var_name] [find_type (f,file;d,dir)] [base] [pattern]" "$@"

	# need use variable to "return" result
	result_var_name=$1
	find_type=$2
	shift;shift
	eval $result_var_name=""

	targets=`func_find_type $find_type $*`
	func_select_line $result_var_name shortest "$targets"
}

function func_vi_conditional {
	if [ $(func_sys_info | grep -c "^cygwin") = 0 ] ; then
		# non-cygwin env: original path style + front job. 

		# use gvim when GUI running and gvim available, otherwise vim if available, otherwise vi
		[ -n "$DISPLAY" ] && (command -v gvim &> /dev/null) && vi_cmd=gvim 
		[ -z "$vi_cmd" ] && (command -v vim &> /dev/null) && vi_cmd=vim
		[ -z "$vi_cmd" ] && vi_cmd=vi

		# why? seems direct use "vim" will not trigger the "vim" alias which could cause infinite loop
		# note: seems in ubuntu gui, not need "&" to make it background job
		#$vi_cmd "$@"
		$vi_cmd --version | grep -q '+clientserver' && $vi_cmd --servername SINGLE_VIM --remote-tab "$@" || $vi_cmd "$@"
	else
		# cygwin env: win style path + background job
		parameters=${@:1:$(($#-1))}
		target_origin=${@:$#}

		[ -z "$target_origin" ] && target_cyg="" || target_cyg=`cygpath -w "$target_origin"`
		( \\gvim $parameters $target_cyg & ) &> /dev/null
	fi
}

function func_cd_conditional {
	# shortcut - home
	[ -z "$*" ] && \cd && return 0

	# shortcut - last dir
	if [ "-" = "$*" ] ; then
		\cd - 
		# TODO: (2013-06-12) seems not checking and using func_rvm_cd could also source rvm, why?
		[ "$(type -t func_rvm_cd)" = "function" -a -e "$*/.rvmrc" ] && func_rvm_cd .
		return 0
	fi

	# TODO: (2013-06-12) seems not checking and using func_rvm_cd could also source rvm, why?
	# use rvm's cd function if needed (note, the func_rvm_cd is hacked in .bashrc
	[ "$(type -t func_rvm_cd)" = "function" -a -e "$*/.rvmrc" ] && func_rvm_cd "$*" && return 0

	# otherwise just cd, use "\cd" to avoid infinite loop, since cd is hacked
	\cd "$*"
	func_head_cmd 30 ll
}

function func_vi {
	# shortcut - open a new one
	[ -z "$*" ] && func_vi_conditional && return 0

	# shortcut - only one parameter, and exist
	tag_eval="`func_tag_value $1`"
	[ $# -eq 1 ] && func_vi_conditional "$tag_eval" && return 0

	# set base, evaluated tag or just ./
	[ "$tag_eval" != "$1" ] && base="$tag_eval" && shift || base="./"

	# Find target, if cache version return error, try no-cache version
	func_find_cache result_target f $base $* || func_find result_target f $base $*

	# use original paramters if no target found
	[ -n "$result_target" ] && func_vi_conditional "$base/$result_target" || func_vi_conditional "$@"
}

function func_cd {
	# TODO: seem using "../paygat" will fail, possbile to make it work?

	# shortcut - home
	[ -z "$*" -o "-" = "$*" ] && func_cd_conditional "$*" && return 0

	# shortcut - only one parameter, and exist in current dir
	[ $# -eq 1 ] && [ -d $1 ] && func_cd_conditional $1 && return 0

	# shortcut - only one parameter, and exist
	tag_eval="`func_tag_value $1`"
	[ $# -eq 1 ] && [ -d $tag_eval ] && func_cd_conditional $tag_eval && return 0

	# otherwise need search
	[ "$tag_eval" != "$1" ] && base="$tag_eval" && shift || base="./"

	# Find target, If cache version return error, try no-cache version
	func_find_cache result_target d $base $* || func_find result_target d $base $*

	[ ! -e $base/$result_target ] && echo "ERROR: $base/$result_target not exist!"
	[ -d $base/$result_target ] && func_cd_conditional $base/$result_target || func_cd_conditional `dirname $base/$result_target`
}

function func_ls { 
	# TODO: seem using "../paygat" will fail, possbile to make it work?

	# shortcut - home
	[ -z "$*" -o "-" = "$*" ] && func_ls_conditional "$*" && return 0

	# shortcut - only one parameter, and exist
	tag_eval="`func_tag_value $1`"
	[ $# -eq 1 ] && [ -d $tag_eval ] && func_ls_conditional $tag_eval && return 0

	# FOR_DEV: w | !source /home/ouyangzhu/.myenv/env_func_bash; func_ls dev

	# TODO: how to distiguish ll/ls/lla etc
	# TODO: Avoid Filename_Expansion
	# TODO: For Cmd History: ls the cmd output dir?

	# Translate tag
	base="./"
	if [[ -n "`func_tag_text_value $1`" ]] ;then 
		base="`func_tag_eval_value $1`/"
		shift
	fi
	pathPattern=`echo "$*" | sed -e '/^$/q;s/ /*\//g;s/$/*/'`

	echo ------------------------------------"$base/$pathPattern"
	ls -lhtrF --color=auto $base/$pathPattern

	# Tmp Cmd
	#search=`echo "$*" | sed -e '/^$/q;s/ \|^\|$/.*/g'`
	#[[ -n $search ]] && search="-iregex $search"
	#find $base $search 
}

function func_head_cmd {
	func_param_check 2 "Usage: $FUNCNAME [show_lines] [cmd]" "$@"

	show_lines=$1
	shift

	cmd_result=`eval "$*"`
	func_head $show_lines "$cmd_result"
}

function func_gen_list {
	# TODO: make a conversion of $type+l_me.txt ?
	#[ "`realpath $base`" = "`realpath $HOME`" ] && echo yes || echo no
	func_param_check 3 "Usage: $FUNCNAME [find_type (f,file;d,dir)] [base] [fl_name]" "$@"

	find_type=$1
	base=$2
	listfile=$3
	[ -e "$base/$listfile" ] && return 0
	[ ! -w "$base" ] && return 1

	# make the path relative to the base, for better compitability
	echo "$base/$listfile not exist, create it..." 1>&2
	\cd $base &> /dev/null
	[ -w ./ ] && find -L ./ -type $find_type > $listfile || echo "ERROR: no write permisson for $PWD!"
	\cd - &> /dev/null
}

function func_gen_list_f_me_git_only { 
	src_git=$HOME/.git
	src_add=$MY_ENV/list/myenv_fl_add.lst
	target=$MY_ENV/zgen/myenv_fl_git1.lst
	target_small=$MY_ENV/zgen/myenv_fl_git2.lst

	[ ! -e $src_git -o ! -e $src_add ] && echo -e "ERROR: ${src_git} or ${src_add} not exists!" && exit 1

	echo -e "INFO: Generating git file list to: $target"
	\cd $HOME && git ls-files > $target; \cd - &> /dev/null

	echo -e "INFO: Generating git compact file list to: $target_small"
	sed -e "s/\/.*//;" $target | sort -u > $target_small
}

function func_gen_list_f_me { 
	filelist_all=$MY_ENV/.fl_me.txt
	filelist_git=$MY_ENV/zgen/myenv_fl_git1.lst
	src_add=$MY_ENV/list/myenv_fl_add.lst

	[ -e $filelist_all ] && return 0

	echo -e "INFO: Generating full file list to: $filelist_all"
	[ ! -e $filelist_git ] && func_gen_list_f_me_git_only

	sed -e "s/^/..\//" $filelist_git > $filelist_all
	sed -e "/^\s*$/d;/^\s*#/d;" $src_add | while read line; do
		func_path_eval candidate $line
		[ -f "$candidate" ] && echo "$candidate" >> $filelist_all 
		[ -d "$candidate" ] && find "$candidate" -type f >> $filelist_all 
	done
}

function func_grep_cmd {
	func_param_check 2 "Usage: $FUNCNAME <search_str> <cmd>" "$@"

	search_str=$1
	shift
	eval "$@" | grep "$search_str"
}

function func_grep_dir_cached {

	# TODO
	# - seems can not support grepfile "aaa\|bbb"
	# - seems can not add more options
	func_param_check 3 "Usage: $FUNCNAME [base] [suffix] [search]*" "$@"

	base=$1
	file_suffix=`[ "$2" = "ALL" ] && echo "" || echo ".$2"`
	shift;shift

	filelist=.fl_me.txt
	grep_result=.grep_me.txt

	func_gen_list f $base $filelist || func_die "ERROR: failed to gen $base/$filelist"

	# Get search string and options
		# Case need handle
		# no options, just search string
		# "-" or " -" in search string
		# multiple options with values

		# Option 1
		# TODO: can not support multiple option, like " -a a -b b"
		# TODO: option is whole string if no option there
		#parameters="$*"
		#options=${parameters/#* -/ -}
		#search=${parameters/% -*/}

		# Option 2
		# TODO: can not support multiple option, like " -a a -b b", since sed not support non-greedy regex
		# TODO: how to avoid " -" in quoted string, since " or ' is not there after pipe
		options=`echo "$*" | sed -e '/ -/!d;s/^.* -/ -/'`					# first " -" not in " or '
		search=`[ -z "$options" ] && echo "$*" || echo "$*" | sed -e "s/$options//;"`		# remove all options, $options empty will cause sed have error

	# we treat path in search text as .
	search=${search//\\/.}							# make the path sep compatible
	search=${search//\//.}							# make the sed (tput) coloring works

	# Jump to base, since the filelist is using relative path
	\cd $base
	grep $suffix'$' $filelist	| \
	# Step: remove files not need to grep (for "grepfile")
	sed -e "/\/.svn\//d" 		| \
	sed -e "/\/.hg\//d" 		| \
	sed -e "/\/.git\//d"		| \
	sed -e "/\/.lnk\//d"		| \
	sed -e "/\/.metadata\//d"	| \
	sed -e "/\/.class$\//d"		| \
	sed -e "/.grep_result.txt/d"	| \
	sed -e "/.grep_me.txt/d"	| \
	sed -e "/\/.jar$\//d"		| \
	# Step: special removal, the target is mvn, but might cause miss-hit!
	sed -e "/\/target\//d"		| \
	# Step: remove the fileist itself
	sed -e "/$filelist$/d"		| \
	# Step: grep result, -I: ignore binary, -oE & .{0.20}: only matched part and 20 char around
	xargs --delimiter="\n" grep -d skip -I -i $options -oE ".{0,20}$search.{0,20}" | \
	# store result for later ref
	tee $grep_result		| \
	# re-color the result, since pipe swiped color even using "--color" in grep
	sed -e "s/$search/$(tput setaf 1)&$(tput sgr0)/I"

	# Jump back
	\cd -
}

function func_grep_myenv {
	func_param_check 1 "Usage: $FUNCNAME [search]*" "$@"

	func_gen_list_f_me
	func_grep_dir_cached $MY_ENV ALL "$*"
}

function func_head {
	func_param_check 2 "Usage: $FUNCNAME [show_lines] [text]" "$@"

	show_lines=$1
	shift

	total_lines=$(echo "$*" | wc -l)
	echo "$*" | sed -n -e "1,${show_lines}p;${show_lines}s/.*/( ...... WARN: more lines suppressed, $total_lines total ...... )/p"
}

function func_ip {
	if [ $(func_sys_info | grep -c "^cygwin") = 0 ] ; then
		# non-cygwin env: ifconfig
		/sbin/ifconfig | sed -n -e '/inet addr/s/.*inet6* addr:\s*\([.:a-z0-9]*\).*/\1/p'	# IPv4
		/sbin/ifconfig | sed -n -e '/inet6* addr/s/.*inet6* addr:\s*\([.:a-z0-9]*\).*/\1/p'	# IPv4 & IPv6
	else
		# seem directly pipe the output of ipconfig is very slow
		raw_data=$(ipconfig) ; echo "$raw_data" | sed -n -e "/IPv[4] Address/s/^[^:]*: //p"	# IPv4
		raw_data=$(ipconfig) ; echo "$raw_data" | sed -n -e "/IPv[46] Address/s/^[^:]*: //p"	# IPv4 & IPv6
		#ipconfig | sed -n -e '/inet addr/s/.*inet addr:\([.0-9]*\).*/\1/p'
	fi
}

function func_mkdir_cd { 
	func_param_check 1 "Usage: $FUNCNAME [path]" "$@"

	mkdir -p "$@" 				&&
	# why need such complex eval?
	eval \cd "\"\$$#\""
}

function func_show_resp { 
	func_param_check 1 "Usage: $FUNCNAME [url]" "$@"

	echo "sending request to: $1"
	wget --timeout=2 --tries=1 -O - 2>&1 "$1"	\
	| sed -e '/'${1//\//.}'/d'			\
	| sed -e '/^Resolving/d'			\
	| sed -e '/^Length/d'				\
	| sed -e '/^Saving/d;/100%.*=.*s/d'		\
	| sed -e '/0K.*0.00.=0s/d'			\
	| sed -e '/^$/d'
}

function func_mvn_gen { 
	func_param_check 2 "Usage: $FUNCNAME [name] [type(war/jar)]" "$@"
	
	name=$1
	type=$2
	case "$type" in
	war)
		#mvn archetype:generate -DgroupId=com.test -DartifactId=$name -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false
		mvn archetype:generate -DgroupId=com.test -DartifactId=$name -DarchetypeCatalog=local -DarchetypeGroupId=com.tpl.archetype -DarchetypeArtifactId=tpl-war-archetype -DarchetypeVersion=1.1-SNAPSHOT -DinteractiveMode=false
		mkdir -p $name/src/main/java
		;;
	jar)
		mvn archetype:generate -DgroupId=com.test -DartifactId=$name -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
		mkdir -p $name/src/main/resources
		;;
	*)
		echo "ERROR: type must be war/jar"
		exit 1
	esac
}

function func_svn_backup { 
	[ -n "$1" ] && src_path="$1" || src_path="."

	src_name=$(basename $(readlink -f $src_path))
	tmp_path=$MY_TMP/${src_name}_svn_export

	# current dir is already project
	[ -e ./.svn ] && svn export $src_path $tmp_path && return 0
	
	# projects are in subdir
	mkdir -p $tmp_path
	for dir in $(find $src_path -maxdepth 1 -type d) ; do 
		[ -n "$dir" ] && [ -e $dir/.svn ] && svn export $dir/  $tmp_path/$(basename $dir)
	done

	# backup
	func_backup_dated $tmp_path
	[ -e "$tmp_path" ] && rm -rf $tmp_path
}

function func_svn_update { 
	[ -n "$1" ] && src_path="$1" || src_path="."

	# current dir is already project
	[ -e $src_path/.svn ] && svn update $src_path && return 0
	
	# projects are in subdir
	for dir in $(find $src_path -maxdepth 1 -type d) ; do 
		# suppress blank line and external file in output: svn update $dir/ | sed "/[Ee]xternal \(item into\|at revision\)/d;/^\s*$/d"
		[ -n "$dir" ] && [ -e $dir/.svn ] && svn update $dir/ 
	done
}

function func_git_pull { 
	[ -n "$1" ] && \cd $1
	git pull origin master && git status
	[ -n "$1" ] && \cd -
}

function func_git_status { 
	[ -n "$1" ] && \cd $1
	git status 	
	[ -n "$1" ] && \cd -
}

function func_git_commit_push { 
	[ -e "$1" ] && target="$1" && \cd "$1" && shift
	[ -n "$*" ] && comment="$*" || comment="update from $(hostname)"

	# git add -A: in git 2.0, will add those even not in current dir (which is what we want), just wait the 2.0
	git pull origin master			&&
	git add -A				&&
	git commit -a -m "$comment" 		&&
	git push origin				&&
	git status 				&&
	func_gen_list_f_me

	[ -n "$target" ] && \cd -
}

function func_ssh_agent_init {
	# do nothing if already set
	# The unison remote style can not accept .bashrc have output
	#[ -n "$SSH_AUTH_SOCK" ] && echo "INFO: ssh agent already exist: $SSH_AUTH_SOCK" && return 0

	ssh_agent_cmd="ssh-agent -s"
	ssh_agent_env_tmp=~/.ssh/ssh_agent_env_tmp

	# reuse if already started
	. "${ssh_agent_env_tmp}" &> /dev/null

	# The unison remote style can not accept .bashrc have output
	#ps -ef | grep "${SSH_AGENT_PID}" | grep ssh-agent | grep -v grep > /dev/null && echo "INFO: reuse exist agent: $SSH_AUTH_SOCK" && return 0
	ps -ef | grep "${SSH_AGENT_PID}" | grep ssh-agent | grep -v grep > /dev/null && return 0

	# start a new one
	echo -e "INFO: Initialising new SSH agent...\n"
	${ssh_agent_cmd} | sed "s/^echo/#echo/" > "${ssh_agent_env_tmp}"
	chmod 600 "${ssh_agent_env_tmp}"
	. "${ssh_agent_env_tmp}" > /dev/null
	ssh-add ~/.ssh/ouyangzhu_duowan
}

function func_ssh_with_jump {
	func_param_check 1 "Usage: $FUNCNAME [target]" "$@"

	ip_addr=`getent hosts $1 | sed "s/\s\+.*$//"`
	[[ -z $ip_addr ]] && ip_addr=$1

	PORT=32200
	JUMP_MACHINE=dw
	
	shift
	ssh -t $JUMP_MACHINE "ssh -p $PORT $ip_addr $@"

	# TODO: check the $1, if it is a ip, should not parse as unique_name
	# TODO: add function for run cmd on multiple host
	# Demo: func_ssh_with_jump 222.88.95.197 
}

function func_scp_with_jump {
	func_param_check 2 "Usage: $FUNCNAME [source] [target]" "$@"

	PORT=32200
	JUMP_MACHINE=dw

	source=$1
	sourceName=$(basename $source)
	tmpTransferName=tmp_transfer_`func_dati`_${sourceName}
	target=$2
	targetDir=$(dirname ${target##*:})
	targetCmd="mkdir -p $targetDir"
	targetAddr=${target%%:*}

	if [[ $(echo $1 | grep -c ":") == 1 ]] 
	then
		echo "Downloading ..."

		# download content to jump machine
		ssh $JUMP_MACHINE "scp -r -P $PORT $source ~/$tmpTransferName"

		# create dir and download content to local machine 
		$targetCmd
		[[ -d $target ]] && targetFullName=$target/$sourceName
		scp -r -P $PORT ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName $targetFullName
	else
		echo "Uploading ..."

		# upload content to jump machine
		scp -r -P $PORT $source ouyangzhu@$JUMP_MACHINE:~/$tmpTransferName

		# create dir and upload content to target machine in jump machine
		ssh $JUMP_MACHINE "ssh -p $PORT $targetAddr $targetCmd"
		# TODO: support rename in target (see above)
		ssh $JUMP_MACHINE "scp -r -P $PORT ~/$tmpTransferName $target"
	fi

	# delete tmp file in jump machine
	ssh $JUMP_MACHINE "rm -rf ~/$tmpTransferName"

	# Note: seems using ProxyCommand is a better way (not totally work yet), see ~/.ssh/config for more detail

	# Improve: the file name was changed to tmp_xxx
	# Improve: support unique_name (need translate, since the jump machine didn't set the hosts)
	# Improve: support file name with wildcard
	# Improve: cache the file based on MD5?
	# Improve: support all senario 
	#	L > R	I	cmd on L(src=L-Path		target=J-Host-Tmp)		II: cmd on J(src=J-Tmp	target=R-Host-Path)
	#	R > L	II	cmd on J(src=R-Host-Path	target=J-Tmp)			II: cmd on L(src=L-Path	target=J-Host-Tmp)
	#	R1 > R2	III	cmd on J(src=R1-Host-Path	target=J-Tmp)			II: cmd on J(src=J-Tmp	target=R2-Host-Tmp)
	#
	#	rule for scp exe location		J if $1 contains :, otherwise L
	#	rule for scp exe stage 1 src		directly use
	#	rule for scp exe stage 1 target		J-Tmp if $1 contains :, otherwise J-Host-Tmp
	#	rule for scp exe stage 2 src		J-Tmp if $2 contains :, otherwise directly use
	#	rule for scp exe stage 2 target		directly use if $2 contains :, otherwuse J-Host-Tmp
	#
	#	and mkdir?

	# Demo: 
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test
		#func_scp_with_jump ~/amp/test/t1 ouyangzhu@222.134.66.106:~/test1
		#func_scp_with_jump ~/amp/test ouyangzhu@222.134.66.106:~/test2/test
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test/t1 ~/amp/2012-11-01/test1
		#func_scp_with_jump ouyangzhu@222.134.66.106:~/test ~/amp/2012-11-01/test
}

function func_terminator { 
	if [ $(func_sys_info | grep -c "^cygwin") = 0 ] ; then
		# non-cygwin env: original program
		terminator --title SINGLE_TERMINATOR $*
	else
		startxwin &> /dev/null	# just ensure X server started
		raw_data=$(ipconfig)
		local_ip=`echo "$raw_data" | sed -n -e "/IPv[4] Address/s/^[^:]*: //p" | head -1`
		# both --maximise/--fullscreen are not really work
		ssh workvm "DISPLAY=$local_ip:0.0 terminator --geometry=1910x1010+0+0 --title Gnome-Terminator&> /dev/null &" &> /dev/null
	fi
}

function func_sys_net {
	usage="Usage: $FUNCNAME [interface] [interval], interfaces: "$(ifconfig | sed '/^\s\+/d;/^\s*$/d;s/\s\+.*//;/lo/d;') 
	func_param_check 1 $usage "$@"

	interface=$1
	sleep_time=${2-2}
	rx_before=$(ifconfig $interface | sed -n -e "s/^.*RX bytes:\([0-9]*\).*/\1/p")
	tx_before=$(ifconfig $interface | sed -n -e "s/^.*TX bytes:\([0-9]*\).*/\1/p")
	while : ; do
		sleep $sleep_time
		rx_after=$(ifconfig $interface | sed -n -e "s/^.*RX bytes:\([0-9]*\).*/\1/p")
		tx_after=$(ifconfig $interface | sed -n -e "s/^.*TX bytes:\([0-9]*\).*/\1/p")
		rx_result=$(( (rx_after-rx_before)*8/$sleep_time ))
		tx_result=$(( (tx_after-tx_before)*8/$sleep_time ))
		echo -e "$(date "+%Y-%m-%d %H:%M:%S") IN: ${rx_result}/$(( ${rx_result}/1000 )) bps/kbps,\tOUT: ${tx_result}/$(( ${tx_result}/1000 )) bps/kbps"

		rx_before=$rx_after
		tx_before=$tx_after
	done
}

function func_sys_info_os_len {
	(command -v uname &> /dev/null) && uname_info=`uname -a` || uname_info="cmd_uname_not_exist"

	# Note, cygwin is usually 32bit
	if [ $(echo $uname_info | grep -ic "x86_64") -eq 1 ] ; then		echo "64bit"
	elif [ $(echo $uname_info | grep -ic "i[3-6]86") -eq 1 ] ; then		echo "32bit"
	else									echo "unknown"
	fi
}

function func_sys_info_os_ver {
	if [ -e /etc/lsb-release ] ; then					sed -n -e "s/DISTRIB_RELEASE=\(\S*\)/\1/p" /etc/lsb-release
	elif [ "$os_name" = "cygwin" ] ; then					uname -r | sed -e "s/(.*//"
	else									echo "unknown"
	fi
}

function func_sys_info_os_type {
	if [ "$os_name" = "ubuntu" ] && (command -v dpkg &> /dev/null) ; then 
		if (dpkg -l ubuntu-desktop &> /dev/null) ; then			echo "desktop"
		else								echo "server"
		fi
	elif [ "$os_name" = "cygwin" -o "$os_name" = "mingw" ] ; then		echo "desktop"
	elif [ "$os_name" = "linuxmint" ] ; then				echo "desktop"
	else									echo "unknown"
	fi
}

function func_sys_info_os_name {
	(command -v uname &> /dev/null) && uname_info=`uname -a` || uname_info="cmd_uname_not_exist"

	if [ -e /etc/lsb-release ] ; then					sed -n -e "s/DISTRIB_ID=\(\S*\)/\L\1/p" /etc/lsb-release
	elif [ $(echo $uname_info | grep -ic "cygwin") -eq 1 ] ; then		echo "cygwin"
	elif [ $(echo $uname_info | grep -ic "mingw") -eq 1 ] ; then		echo "mingw"
	else									echo "unknown"
	fi
}

function func_sys_info { 
	# format: <os_name>          		_<os_ver>  _<os_len>     _<os_type>               _<unique_name>	_<addInfo>
	# exampe: ubuntu/linuxmint/cygwin/win	_12.04     _64bit/32bit  _desktop/server/win7/xp  _workvm	_precise

	os_name=`func_sys_info_os_name`

	# use cache if cached, need os_name to distiguish cygwin/mingw
	if [ -n $MY_ENV_ZGEN ] ; then						cache_file=$MY_ENV_ZGEN/sys_info_${os_name}
	else									cache_file=/tmp/sys_info_${os_name}
	fi
	[ -e $cache_file ] && cat $cache_file && return

	os_ver=`func_sys_info_os_ver`
	os_len=`func_sys_info_os_len`
	os_type=`func_sys_info_os_type`
	unique_name=`unique_name`

	# addInfo
	if [ "$os_name" = "ubuntu" ] ; then					addInfo=`sed -n -e "s/DISTRIB_CODENAME=\(\S*\)/\L\1/p" /etc/lsb-release`
	fi
	############################################################## (not include in output yet)
	# cpu_type 
	cpu_type="unknown"

	# cpu_len 
	# if [ $(grep -c "flags.* lm " /proc/cpuinfo) -ge 1 ] ; then # lm (long bit), deprecated
	if [ $(getconf -a | grep -c "LONG_BIT\s*64") -eq 1 ] ; then		cpu_len=64bit
	elif [ $(getconf -a | grep -c "LONG_BIT\s*32") -eq 1 ] ; then		cpu_len=32bit
	else									cpu_len="unknown"
	fi
	############################################################## (not include in output yet)

	echo -e "${os_name}_${os_ver}_${os_len}_${os_type}_${unique_name}_${addInfo}" > $cache_file
	cat $cache_file

	# TODO: put this func to another file, pre load as basic functions
}

function func_translate { 
	unique_name=$(hostname)
	[ -z "$unique_name" ] && echo "WARN: command hostid return empty!"

	# check history
	history_txt=$(grep "^$*" -i -A 1 --no-filename $MY_ENV/list/translate_history_*)
	[ -n "$history_txt" ] && echo "$history_txt" && return 0

	func_translate_google "$@" || func_translate_microsoft "$@"
}

function func_translate_IPA_google { 
	echo "WARN: not implemented yet!"
	# IPA: International Phonetic Alphabet (IPA), tells pronunciation of words
	# TODO: google api, IPA extraction: http://www.google.com/dictionary/json?callback=dict_api.callbacks.id100&q=example&sl=en&tl=en
}

function func_translate_google { 
	func_param_check 1 "Usage: $FUNCNAME [words]" "$@" 

	# might useful fields: ie=UTF-8&oe=UTF-8
	if [ $( echo $* | grep -c "[a-z]") -ge 1 ] ; 
	then	data="hl=en&tsel=0&ssel=0&client=t&sc=1&multires=1&otf=2&text=$*&tl=zh-CN&sl=en"	# en > cn
	else	data="hl=en&tsel=0&ssel=0&client=t&sc=1&multires=1&otf=2&text=$*&tl=en&sl=zh-CN"	# cn > en	# why become cn > cn !!??
	fi

	res_raw=`curl -e "http://translate.google.cn/?"							\
		-H 'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:11.0) Gecko/20100101 Firefox/11.0'	\
		-H 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'			\
		-s "http://translate.google.cn/translate_a/t"							\
		-d "$data"`
	[ -z "$res_raw" ] && return 1

	res_simple=`echo $res_raw | awk -F"," '{printf "%s\n", $1}' | awk -F"\"" '{print $2}'`
	echo $res_simple
	echo $res_raw
	echo -e "$*\t$res_simple\n\t$res_raw" >> $MY_ENV/list/translate_history_${unique_name}
}

function func_translate_microsoft { 
	func_param_check 1 "Usage: $FUNCNAME [words]" "$@" 

	access_token_tmp=/tmp/ms_translation_api_access_token
	access_token_compare=/tmp/ms_translation_api_access_token_compare

	access_token_uri="https://datamarket.accesscontrol.windows.net/v2/OAuth2-13"
	# parameters below are applied from https://datamarket.azure.com
	post_content="grant_type=client_credentials&client_id=ouyzhu&client_secret=0yAn46ClllxZk4CuY2tGkjo9Sl&scope=http://api.microsofttranslator.com"
	translate_uri_cn2en="http://api.microsofttranslator.com/v2/Http.svc/Translate?from=zh-CHS&to=en&text="
	translate_uri_en2cn="http://api.microsofttranslator.com/v2/Http.svc/Translate?from=en&to=zh-CHS&text="

	# Check if valid access token exist
	if [ ! -e "$access_token_tmp" ] || (( $(date +%s) > $(tail -1 $access_token_tmp) )) ; then
		echo "INFO: requesting ms translate api token"
		curl -s --data $post_content $access_token_uri > $access_token_tmp || return 1

		expire_on=$(sed -e 's/.*ExpiresOn=\([^&]*\)&.*/\1/' $access_token_tmp)
		echo -e "\n$expire_on" >> $access_token_tmp

		#expire_in=$(sed -e 's/.*"expires_in":"\([^"]*\)".*/\1/' $access_token_tmp)
		#touch -d "$expire_in seconds" $access_token_tmp
	fi
	access_token=$(head -1 "$access_token_tmp" | sed -e 's/.*"access_token":"\([^"]*\)".*/\1/')

	# Translate, both '-H "ContentType: text/plain"' and '&contentType=text%2Fplain' NOT work (always get xml)
	if [ $( echo $* | grep -c "[a-z]") -ge 1 ] ; 
	then res_raw=$(curl -s -H "ContentType: text/plain" -H "Authorization: Bearer $access_token" "${translate_uri_en2cn}$*")
	else res_raw=$(curl -s -H "ContentType: text/plain" -H "Authorization: Bearer $access_token" "${translate_uri_en2cn}$*")
	fi
	[ -z "$res_raw" ] && return 1

	echo $res_raw
	echo -e "$*\n\t$res_raw" >> $MY_ENV/list/translate_history_${unique_name}
}

function func_delete_dated { 
	func_param_check 1 "Usage: $FUNCNAME <path> <path> ..." "$@" 

	# the path might have blank, so use $*, and embrace with "" (many place used this)
	targetDir=$MY_TMP/`func_date`

	[[ ! -e $targetDir ]] && mkdir $targetDir
	mv "$@" $targetDir
}

function func_backup_dated { 
	func_param_check 1 "Usage: $FUNCNAME <path>" "$@" 
	[ $# -ge 2 ] && func_die "ERROR: only one path/parameter supported"

	srcPath="$1"
	fileName=$(basename "$srcPath")
	targetFile=`func_dati`_`uname -n`_"$fileName"
	bakPath=("$MY_DOC/DCB/DatedBackup" "$HOME/ampext/backup")

	# if path is a directory, zip it first
	if [ -d "$srcPath" ]; then
		# need update the var to packed ones
		targetFile=$targetFile.zip 
		packFile=$MY_TMP/$targetFile
		echo -e "INFO: Creating zip file for backup: $packFile"
		zip -rq "$packFile" "$srcPath"
		srcPath="$packFile"
	fi

	for path in "${bakPath[@]}"
	do
		if [ -e "$path" ]; then
			cp "$srcPath" "$path/$targetFile"
			[ -e "$path/$targetFile" ] && echo -e "INFO: backup success: `ls -lh \"$path/$targetFile\"`" 
			copied=$success
		else
			echo -e "WARN: backup failed, path not exist ($path)" 
		fi
	done

	[ -e $packFile ] && echo -e "INFO: Deleting tmp zip file: $packFile" && rm "$packFile"
	[[ $copied != $success ]] && echo -e "\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n! Failed to do any backup!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
}

function func_backup_listed { 
	# TODO: merge with dated_backup?
	# source ~/.myenv/env_func_bash ; func_backup_listed myenv_full $MY_ENV/zgen/myenv_fl_git2.lst $MY_ENV/list/myenv_fl_add.lst

	func_param_check 2 "Usage: $FUNCNAME <tag> <filelists>*" "$@" 

	tmp_dir=$MY_TMP/$1
	[ -e "$tmp_dir" ] && rm -rf $tmp_dir
	mkdir -p $tmp_dir
	shift
	source=$*

	for fl in $source ; do 
		[ ! -e $fl ] && echo -e "WARN: file list ($fl) not exist!" && continue
		sub_name=`basename ${fl}`
		sub_dir=$tmp_dir/${sub_name%%.*}
		mkdir $sub_dir

		# TODO duplicated code block - start - evalfl1
		sed -e "/^\s*$/d;/^\s*#/d;" $fl | while read line; do
			# eval path, check empty value
			[ -n "$line" ] && candidate=`func_tag_eval $line` || continue
			[ -z "$candidate" ] && echo -e "WARN: candiate is empty: $line !" && continue

			# Try $HOME as base (myenv backup need this for git listed files)
			[ -e "$HOME/$candidate" ] && cp --no-preserve=all -R "$HOME/$candidate" $sub_dir && continue
			[ -e "$candidate" ] && cp --no-preserve=all -R "$candidate" $sub_dir || continue
		done
		# TODO duplicated code block - end - evalfl1

		# dirty check 1, for myenv bak, change its ACL, otherwise can not open/delete that dir
		dirty_dir=fstab.d
		[ -e $sub_dir/$dirty_dir ] && 					\
			getfacl $MY_TMP | setfacl -f - $sub_dir/$dirty_dir &&	\
			getfacl $MY_TMP | setfacl -f - $sub_dir/$dirty_dir/*

		# dirty check 2, for myenv bak, not want the .unison log file 
		[ -e $sub_dir/.unison ] && find $sub_dir/.unison/ -type f | grep -v ".*.prf" | xargs rm &> /dev/null
	done

	func_backup_dated $tmp_dir
	[ -e "$tmp_dir" ] && rm -rf $tmp_dir

	#sed -e '/`\|\$/p;/^\s*$/d;/^\s*#/d;s/\/.*//;' $source | sort -u >> $tmp_dir/.fl_me.txt 
	#awk '/^\s*$/{};/^\s*#/{};/`\|\$/{print $0;next;};/\//{gsub("\/.*","",$0);print $0};' $source | sort -u >> $tmp_dir/.fl_me.txt 
	#awk '/^\s*$/{print "----"$0};/^\s*#/{print "----"$0};/`\|\$/{print $0;next;};' $source | sort -u >> $tmp_dir/.fl_me.txt 

	#func_gen_list_f_me	
	#bash $MY_ENV/util/listed_backup.sh myenv_full $MY_ENV/zgen/myenv.lst $MY_ENV/list/myenv_add.lst
	#$MY_ENV/util/listed_backup.sh
}

function func_run_file_java {
	file=$1
	file_name=`basename $file`
	tmp_dir=$(func_tag_value tt)/$(func_time)

	cp -f $file $tmp_dir || return 1
	\cd $tmp_dir &> /dev/null
	rm ${file_name/.java/.class} &> /dev/null
	javac $file_name
	java -cp . ${file_name%.java}
}

function func_run_file {
	func_param_check 1 "Usage: $FUNCNAME <file>" "$@" 
	
	file=$1
	[ ! -e "$file" ] && echo "ERROR: $file not exist!" && return 1

	if [[ "$file" = *.java ]] ; then
		func_run_file_java $file 
	elif [[ "$file" = *.rb ]] ; then	ruby $file;
	elif [[ "$file" = *.sh ]] ; then	bash $file;
	elif [[ "$file" = *.py ]] ; then	python $file;
	elif [[ "$file" = *.bat ]] ; then	cmd $file;
	elif [[ "$file" = *.exe ]] ; then	cmd $file;
	elif [[ "$file" = *.ps1 ]] ; then	/cygdrive/c/Windows/system32/WindowsPowerShell/v1.0/powershell.exe -ExecutionPolicy RemoteSigned -File ${file//\\/\/}
	elif [[ "$file" = *.groovy ]] ; then	groovy $file;
	else
		echo "ERROR: can not run file $file !"
	fi
}

function func_ctrl_me {
	func_param_check 2 "Usage: $FUNCNAME <target> <action>" "$@" 

	name=$1
	action=$2
	parent=${name%%_*}
	script=/data/${parent}/${name}/bin/${action}.sh

	[ ! -e "$script" ] && func_die "ERROR: $script not exist"
	$script 
}

